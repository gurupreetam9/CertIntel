
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function incomingData() {
      return request.resource.data;
    }

    function existingData() {
      return resource.data;
    }
    
    function affectedKeys() {
      return request.resource.data.diff(resource.data).affectedKeys();
    }

    // USERS Collection
    // Stores basic user profiles (student or admin role)
    match /users/{userId} {

      function studentIsCreatingOwnProfile() {
        let data = incomingData();
        return isAuthenticated() &&
               isOwner(userId) &&
               data.uid == userId &&
               data.email == request.auth.token.email &&
               data.role == 'student' &&
               data.createdAt == request.time &&
               data.updatedAt == request.time &&
               data.containsKey('displayName') &&
               data.linkRequestStatus == 'none' && // Ensure initial status
               !data.containsKey('adminUniqueId') && // Student cannot set admin ID for themselves
               !data.containsKey('associatedAdminFirebaseId') && // Not set at initial creation
               !data.containsKey('associatedAdminUniqueId') && // Not set at initial creation
               data.keys().hasOnly(['uid', 'email', 'role', 'displayName', 'rollNo', 'linkRequestStatus', 'createdAt', 'updatedAt']);
      }

      function adminIsCreatingOwnProfile() {
        let data = incomingData();
        return isAuthenticated() &&
               isOwner(userId) &&
               data.uid == userId &&
               data.email == request.auth.token.email &&
               data.role == 'admin' &&
               data.createdAt == request.time &&
               data.updatedAt == request.time &&
               data.containsKey('displayName') &&
               data.containsKey('adminUniqueId') && // Admin must have their unique ID
               data.keys().hasOnly(['uid', 'email', 'role', 'displayName', 'adminUniqueId', 'createdAt', 'updatedAt']);
      }
      
      // Student can update their own display name, roll number, and linking information.
      // Core fields like uid, email, role, createdAt cannot be changed by student.
      // adminUniqueId cannot be set/changed by a student.
      function studentIsUpdatingOwnAllowedFields() {
        let immutableFields = ['uid', 'email', 'role', 'createdAt', 'adminUniqueId'];
        let studentModifiableFields = ['displayName', 'rollNo', 'updatedAt', 'linkRequestStatus', 'associatedAdminFirebaseId', 'associatedAdminUniqueId'];
        
        return isAuthenticated() &&
               isOwner(userId) &&
               incomingData().role == 'student' && // Role must be student
               existingData().role == 'student' && // Role must have been student
               // Ensure immutable fields are not changed
               debug(immutableFields.filter(key => incomingData()[key] != existingData()[key]).size() == 0, "Immutable fields changed check") &&
               // Ensure adminUniqueId is not being set to a non-null value by a student
               (incomingData().adminUniqueId == null || incomingData().adminUniqueId == existingData().adminUniqueId) &&
               // Ensure all keys in the incoming data are either immutable or student-modifiable
               debug(incomingData().keys().hasOnly(immutableFields.concat(studentModifiableFields)), "All keys valid check") &&
               // Ensure only student-modifiable fields are actually being affected (changed)
               debug(affectedKeys().hasOnly(studentModifiableFields), "Affected keys valid check") &&
               incomingData().updatedAt == request.time;
      }

      // Admins can update limited fields on student profiles (specifically link status related by admin actions)
      // This is used when an admin accepts/rejects a student's link request.
      function isAdminUpdatingStudentLinkStatus() {
          return isAuthenticated() &&
                 request.auth.token.role == 'admin' && // Authenticated user must be an admin
                 existingData().role == 'student' && // Target document must be a student
                 incomingData().role == 'student' && // Role must remain student
                 affectedKeys().hasOnly(['linkRequestStatus', 'associatedAdminFirebaseId', 'associatedAdminUniqueId', 'updatedAt']) &&
                 // Immutable fields check
                 incomingData().uid == existingData().uid &&
                 incomingData().email == existingData().email &&
                 incomingData().createdAt == existingData().createdAt &&
                 incomingData().updatedAt == request.time;
      }
      
      // Admin can update their own display name and updatedAt.
      function adminIsUpdatingOwnProfile() {
        return isAuthenticated() &&
               isOwner(userId) &&
               incomingData().role == 'admin' &&
               existingData().role == 'admin' &&
               affectedKeys().hasOnly(['displayName', 'updatedAt']) &&
               incomingData().uid == existingData().uid &&
               incomingData().email == existingData().email &&
               incomingData().createdAt == existingData().createdAt &&
               incomingData().adminUniqueId == existingData().adminUniqueId && // Admin ID cannot change
               incomingData().updatedAt == request.time;
      }

      allow read: if isAuthenticated();
      allow create: if studentIsCreatingOwnProfile() || adminIsCreatingOwnProfile();
      allow update: if studentIsUpdatingOwnAllowedFields() || adminIsUpdatingOwnProfile() || isAdminUpdatingStudentLinkStatus();
      // No general delete for user profiles by users themselves for now.
      allow delete: if false; 
    }

    // ADMINS Collection (secondary collection to quickly find admin by unique ID)
    // Document ID is the admin's Firebase UID.
    match /admins/{adminUserId} {
      function isAdminCreatingOwnAdminEntry() {
        return isAuthenticated() && 
               isOwner(adminUserId) && // Only admin can create their own entry here
               incomingData().userId == adminUserId &&
               incomingData().email == request.auth.token.email &&
               incomingData().containsKey('adminUniqueId') &&
               incomingData().createdAt == request.time;
      }
      
      allow read: if isAuthenticated(); // Admins might need to read other admin details, or students might read for verification
      allow create: if isAdminCreatingOwnAdminEntry();
      allow update: if false; // Admin unique ID should be immutable after creation
      allow delete: if false; // No direct deletion by users
    }

    // STUDENT LINK REQUESTS Collection
    // Stores requests from students to link with admins
    match /studentLinkRequests/{requestId} {
      function studentIsCreatingOwnLinkRequest() {
        let data = incomingData();
        return isAuthenticated() &&
               data.studentUserId == request.auth.uid && // Student creating the request must be the authenticated user
               data.studentEmail == request.auth.token.email &&
               data.containsKey('studentName') &&
               data.containsKey('adminUniqueIdTargeted') && // Admin they want to link to
               data.containsKey('adminFirebaseId') && // Firebase UID of that admin (validated client-side)
               data.status == 'pending' &&
               data.requestedAt == request.time &&
               // Ensure adminFirebaseId corresponds to an actual admin document
               exists(/databases/$(database)/documents/admins/$(data.adminFirebaseId)); 
      }
      
      function adminIsResolvingRequest() {
        let data = incomingData();
        return isAuthenticated() &&
               request.auth.token.role == 'admin' && // Resolver must be an admin
               data.adminFirebaseId == request.auth.uid && // Admin resolving must be the one targeted
               data.studentUserId == existingData().studentUserId && // Student ID cannot change
               (data.status == 'accepted' || data.status == 'rejected') &&
               affectedKeys().hasOnly(['status', 'resolvedAt', 'resolvedBy']) &&
               data.resolvedAt == request.time &&
               data.resolvedBy == request.auth.uid;
      }
      
      // Student can "cancel" (mark as rejected) their own PENDING request
      function studentIsCancellingOwnPendingRequest() {
        return isAuthenticated() &&
               isOwner(existingData().studentUserId) && // Must be owner of the request
               existingData().status == 'pending' && // Only pending requests can be cancelled by student
               incomingData().status == 'rejected' && // Setting status to rejected
               affectedKeys().hasOnly(['status', 'resolvedAt', 'resolvedBy']) && // Allow these fields for cancellation
               incomingData().resolvedAt == request.time &&
               incomingData().resolvedBy == request.auth.uid; // Student resolves their own cancellation
      }

      allow read: if isAuthenticated() && 
                     (isOwner(existingData().studentUserId) || request.auth.uid == existingData().adminFirebaseId);
      allow create: if studentIsCreatingOwnLinkRequest();
      allow update: if adminIsResolvingRequest() || studentIsCancellingOwnPendingRequest();
      // No direct delete for requests by users. Resolution changes status.
      allow delete: if false;
    }
    
    // MONGODB METADATA Collection (placeholder, adjust if used directly with Firestore)
    // Example: /images_metadata/{docId}
    match /images_metadata/{docId} {
      // Only allow authenticated users to create metadata linked to their UID.
      allow create: if isAuthenticated() && incomingData().userId == request.auth.uid;
      // Only allow owners to read or delete their metadata.
      allow read, delete: if isAuthenticated() && isOwner(existingData().userId);
      // Updates could be restricted similarly.
      allow update: if isAuthenticated() && isOwner(existingData().userId);
    }
  }
}
