
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // User is creating their own 'admin' role profile
    function isAdminCreatingOwnAdminProfile(request, resource) {
      let data = request.resource.data;
      return data.userId == request.auth.uid &&
             data.email == request.auth.token.email &&
             data.keys().hasAll(['userId', 'adminUniqueId', 'email', 'createdAt']) &&
             data.keys().hasOnly(['userId', 'adminUniqueId', 'email', 'createdAt']);
    }

    // User is updating their own 'admin' role profile
    function isAdminUpdatingOwnAdminProfile(request, resource) {
      let data = request.resource.data;
      let existingData = resource.data;
      return data.userId == existingData.userId && // Cannot change userId
             data.email == existingData.email && // Cannot change email
             data.adminUniqueId == existingData.adminUniqueId && // Cannot change adminUniqueId
             data.createdAt.toMillis() == existingData.createdAt.toMillis() && // Cannot change createdAt
             data.keys().hasOnly(['userId', 'adminUniqueId', 'email', 'createdAt']); // No other fields allowed
    }

    // User is creating their own 'student' role profile
    function studentIsCreatingOwnProfile(request, resource) {
      let data = request.resource.data;
      // Fields that MUST be present and correct
      let baseChecks = data.uid == request.auth.uid &&
                       data.email == request.auth.token.email && // Ensure email matches token if available and verified
                       data.role == 'student' &&
                       data.keys().hasAll(['uid', 'email', 'role', 'createdAt', 'updatedAt', 'displayName']);

      // Fields that a student MUST NOT set on their own profile creation.
      // 'adminUniqueId' is for admin users. 'associatedAdminFirebaseId' is set later if linking.
      let forbiddenFieldsAreAbsentOrNull =
          (data.adminUniqueId == null || !data.keys().hasAny(['adminUniqueId'])) &&
          (data.associatedAdminFirebaseId == null || !data.keys().hasAny(['associatedAdminFirebaseId']));


      // All keys present must be from the allowed set for initial student creation
      let allowedKeysForStudentCreate = [
        'uid', 'email', 'role', 'createdAt', 'updatedAt', 'displayName',
        'rollNo', 'linkRequestStatus', 'associatedAdminUniqueId'
      ];
      let onlyAllowedKeysPresent = data.keys().hasOnly(allowedKeysForStudentCreate);

      return baseChecks && forbiddenFieldsAreAbsentOrNull && onlyAllowedKeysPresent;
    }

    // Student is updating their own profile (e.g. display name, roll no, or linking info)
    function studentIsUpdatingOwnAllowedFields(request, resource) {
      // 1. User must be the owner of the document
      if (request.auth.uid != resource.data.uid) { return false; }

      // 2. The role must be 'student' and must not change
      if (resource.data.role != 'student' || request.resource.data.role != 'student') { return false; }

      // 3. Define immutable fields for a student (cannot be changed by student after creation)
      //    and fields a student IS allowed to change.
      let immutableByStudent = ['uid', 'email', 'role', 'createdAt', 'adminUniqueId']; // adminUniqueId should always be null/unchanged by student
      let changeableByStudent = ['displayName', 'rollNo', 'updatedAt',
                                 'linkRequestStatus', 'associatedAdminFirebaseId', 'associatedAdminUniqueId'];

      let allAllowedKeysInRequest = immutableByStudent.concat(changeableByStudent);

      // 4. Check if any immutable field is being attempted to change
      for (let i = 0; i < immutableByStudent.length; i = i + 1) {
        let field = immutableByStudent[i];
        if (request.resource.data[field] != resource.data[field]) {
          // Allow createdAt to be "unchanged" if timestamps are equivalent
          if (field == 'createdAt' && request.resource.data[field].toMillis() == resource.data[field].toMillis()) {
            continue;
          }
          return false; // Attempt to change an immutable field
        }
      }
      
      // 5. Ensure all keys in the request are either immutable (and checked above) or in the changeable list.
      //    This prevents adding arbitrary fields.
      let requestKeys = request.resource.data.keys();
      for (let i = 0; i < requestKeys.length; i = i + 1) {
          let key = requestKeys[i];
          if (!allAllowedKeysInRequest.hasAny([key])) {
              return false; // An unexpected field is present in the request
          }
      }
      
      // 6. Check that only allowed fields are ACTUALLY changing value
      let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
      if (!changedKeys.hasOnly(changeableByStudent)) {
          return false; // A field changed that wasn't in the 'changeableByStudent' list
      }

      return true; // All checks passed
    }

    // Admin role check from their own user profile
    function isAdmin(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role == 'admin';
    }
    
    // Admin is updating a student's link status (e.g. accepting/rejecting)
    function isAdminUpdatingStudentLinkStatus(request, resource) {
      // Ensure target is a student and remains a student
      if (resource.data.role != 'student' || request.resource.data.role != 'student') { return false; }

      // Define fields admin can change on student profile for link resolution
      let adminAllowedChanges = ['linkRequestStatus', 'associatedAdminFirebaseId', 'updatedAt'];
      let changedKeys = request.resource.data.diff(resource.data).affectedKeys();

      // Check that only these fields are changing
      if (!changedKeys.hasOnly(adminAllowedChanges)) { return false; }

      // Ensure other student-owned data is not modified by admin in this operation
      let studentOwnedFields = ['uid', 'email', 'role', 'createdAt', 'displayName', 'rollNo', 'associatedAdminUniqueId', 'adminUniqueId'];
      for (let i = 0; i < studentOwnedFields.length; i = i + 1) {
        let field = studentOwnedFields[i];
        // If the field is not part of what admin is allowed to change here, it must remain the same
        if (!adminAllowedChanges.hasAny([field]) && request.resource.data[field] != resource.data[field]) {
           if (field == 'createdAt' && request.resource.data[field].toMillis() == resource.data[field].toMillis()) {
            continue;
          }
          return false;
        }
      }
      return true;
    }

    // User Profiles
    match /users/{userId} {
      allow read: if isAuthenticated() && (isOwner(userId) || isAdmin(request.auth.uid));
      allow create: if isOwner(userId) && studentIsCreatingOwnProfile(request, resource);
      allow update: if (
        isOwner(userId) && studentIsUpdatingOwnAllowedFields(request, resource)
      ) || (
        isAuthenticated() && isAdmin(request.auth.uid) && isAdminUpdatingStudentLinkStatus(request, resource)
      );
      allow delete: if false; // Generally, don't allow direct deletion
    }

    // Admin Profiles (separate collection, simplified for unique ID storage)
    match /admins/{adminId} {
      allow read: if isAuthenticated(); // Allow any authenticated user to read admin profiles (e.g., to verify unique ID)
      allow create: if isOwner(adminId) && isAdminCreatingOwnAdminProfile(request, resource);
      allow update: if isOwner(adminId) && isAdminUpdatingOwnAdminProfile(request, resource);
      allow delete: if false;
    }

    // Student Link Requests
    match /studentLinkRequests/{requestId} {
      allow read: if isAuthenticated() && 
                      (isOwner(resource.data.studentUserId) || 
                       (resource.data.adminFirebaseId != null && isOwner(resource.data.adminFirebaseId)));
      allow create: if isAuthenticated() && isOwner(request.resource.data.studentUserId);
      allow update: if isAuthenticated() && 
                       resource.data.adminFirebaseId != null && 
                       isOwner(resource.data.adminFirebaseId) &&
                       request.resource.data.status != resource.data.status && // Status must change
                       request.resource.data.keys().hasOnly(['status', 'resolvedAt', 'resolvedBy']); // Only these fields can be changed by admin
      allow delete: if false;
    }
    
    // Image metadata (images.files and images.chunks are GridFS internal)
    // Rules for these are typically managed by MongoDB itself if using database users,
    // or via application logic if using a general app user for DB access.
    // For Firestore-like rules, you'd define paths like /images.files/{fileId}
    // However, this is for GridFS stored in MongoDB, not Firestore.
    // So, security for GridFS files is handled by your Next.js API routes that interact with MongoDB.
    // The API routes should implement their own authentication and authorization.
  }
}
