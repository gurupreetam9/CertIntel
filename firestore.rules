
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users Collection
    match /users/{userId} {
      // Allow users to read their own profile
      // Allow admins (users with role=='admin' in their own user document) to read any user's profile
      allow read: if request.auth.uid == userId ||
                     (request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');

      allow create: if request.auth.uid == userId;

      // Users can update their own displayName, rollNo (if student), updatedAt,
      // and specific link-related fields for managing their link request.
      // Admins can update specific link-related fields on student profiles they manage.
      allow update: if request.auth.uid == userId &&
                       (
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['displayName', 'rollNo', 'updatedAt', 'linkRequestStatus', 'associatedAdminFirebaseId', 'associatedAdminUniqueId'])
                       );
      // More specific admin update rule - only for linkage fields.
      // This is somewhat redundant if an admin can read any profile and the API handles logic,
      // but good for defense in depth if client tries to update directly.
      // allow update: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' &&
      //                  request.resource.data.role == 'student' && // Admin can only update linkage for students
      //                  request.resource.data.diff(resource.data).affectedKeys().hasOnly(['linkRequestStatus', 'associatedAdminFirebaseId', 'updatedAt']);

      allow delete: if false; // Deletes should be handled by backend functions for cascading cleanup.
    }

    // Admins Collection (for storing admin unique IDs primarily)
    match /admins/{adminId} {
      allow read: if request.auth != null; // Any authenticated user can check if an admin ID exists.
      // Admin profile creation is handled by a Genkit flow which should run with elevated privileges
      // or a more specific rule based on the user creating their own admin entry.
      allow create: if request.auth.uid == adminId && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      allow update, delete: if request.auth.uid == adminId;
    }

    // StudentLinkRequests Collection
    match /studentLinkRequests/{requestId} {
      allow create: if request.auth.uid == request.resource.data.studentUserId; // Student can create their own request

      // Student can read their own request.
      // Admin (whose adminFirebaseId matches the one on the request) can read it.
      allow read: if request.auth.uid == resource.data.studentUserId ||
                     (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' && resource.data.adminFirebaseId == request.auth.uid);

      // Admin (whose adminFirebaseId matches) can update status, resolvedAt, resolvedBy.
      allow update: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' &&
                       resource.data.adminFirebaseId == request.auth.uid &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'resolvedAt', 'resolvedBy']);

      allow delete: if false; // Deletes handled by backend.
    }
  }
}
