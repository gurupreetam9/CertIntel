
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function getRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }

    function isAdmin() {
      return isSignedIn() && getRole(request.auth.uid) == 'admin';
    }

    function isStudent() {
      return isSignedIn() && getRole(request.auth.uid) == 'student';
    }

    // Rules for /users collection
    match /users/{userId} {
      allow read: if isSignedIn();

      // Student creating their own profile
      function studentIsCreatingOwnProfile(userId) {
        let data = request.resource.data;
        let requiredFields = ['uid', 'email', 'role', 'createdAt', 'updatedAt', 'displayName'];
        // Optional for student on creation: rollNo, linkRequestStatus, associatedAdminFirebaseId, associatedAdminUniqueId
        // Student CANNOT set adminUniqueId on creation.
        let allPossibleFieldsForStudentCreate = ['uid', 'email', 'role', 'createdAt', 'updatedAt', 'displayName', 'rollNo', 'linkRequestStatus', 'associatedAdminFirebaseId', 'associatedAdminUniqueId'];

        return request.auth.uid == userId &&
               data.uid == userId &&
               data.email == request.auth.token.email &&
               data.role == 'student' &&
               data.adminUniqueId == null && // Explicitly ensure adminUniqueId is not set by student
               data.keys().hasAll(requiredFields) &&
               data.keys().subsetOf(allPossibleFieldsForStudentCreate) && // Use subsetOf
               data.createdAt == request.time &&
               data.updatedAt == request.time;
      }

      // Admin creating an admin profile (rare, usually through a trusted backend/flow)
      // Or creating user shell if needed by some admin process.
      function adminIsCreatingUserProfile() {
        // Add specific conditions if admins are allowed to create user profiles directly
        return isAdmin() && request.resource.data.uid == userId; // Basic: admin creates user doc matching UID
      }

      allow create: if studentIsCreatingOwnProfile(userId) || adminIsCreatingUserProfile();

      // Student updating their own allowed fields
      function studentIsUpdatingOwnAllowedFields(userId) {
        let incomingData = request.resource.data;
        let existingData = resource.data;

        if (request.auth.uid != userId) { return false; }
        if (incomingData.role != 'student' || incomingData.role != existingData.role) { return false; }
        if (incomingData.uid != existingData.uid) { return false; }
        if (incomingData.email != existingData.email) { return false; }
        if (incomingData.createdAt.toMillis() != existingData.createdAt.toMillis()) { return false; }
        // Student cannot set/change adminUniqueId to a non-null value if it was null, or change it if it was already set (though it shouldn't be for students)
        if (incomingData.adminUniqueId != existingData.adminUniqueId) { return false; }


        let allowedUpdateFields = ['displayName', 'rollNo', 'updatedAt', 'linkRequestStatus', 'associatedAdminFirebaseId', 'associatedAdminUniqueId'];
        let changedKeys = incomingData.diff(existingData).affectedKeys();

        if (changedKeys.size() == 0) { return true; } // Allow "noop" updates
        return changedKeys.hasOnly(allowedUpdateFields);
      }

      // Admin updating a student's profile (e.g., link status after approval)
      function adminIsUpdatingStudentLinkStatus(studentUserId) {
        let incomingStudentData = request.resource.data;
        let existingStudentData = resource.data;
        let allowedAdminUpdateFields = ['linkRequestStatus', 'associatedAdminFirebaseId', 'associatedAdminUniqueId', 'updatedAt'];
        let changedKeys = incomingStudentData.diff(existingStudentData).affectedKeys();

        return isAdmin() &&
               studentUserId == incomingStudentData.uid && // Ensure admin is updating the correct student doc
               incomingStudentData.role == 'student' &&   // Ensure it's still a student
               // Ensure core fields are not changed by admin during this specific operation
               incomingStudentData.uid == existingStudentData.uid &&
               incomingStudentData.email == existingStudentData.email &&
               incomingStudentData.role == existingStudentData.role &&
               incomingStudentData.createdAt.toMillis() == existingStudentData.createdAt.toMillis() &&
               incomingStudentData.displayName == existingStudentData.displayName && // Admin not changing name here
               incomingStudentData.rollNo == existingStudentData.rollNo && // Admin not changing rollNo here
               (changedKeys.size() == 0 || changedKeys.hasOnly(allowedAdminUpdateFields));
      }

      // Admin updating their own profile
      function adminIsUpdatingOwnProfile(userId) {
         let incomingData = request.resource.data;
         let existingData = resource.data;
         if (request.auth.uid != userId) { return false; }
         if (incomingData.role != 'admin' || incomingData.role != existingData.role) { return false; }
         // Add more checks for what an admin can update on their own user profile doc
         let allowedAdminSelfUpdateFields = ['displayName', 'updatedAt']; // Example
         let changedKeys = incomingData.diff(existingData).affectedKeys();
         if (changedKeys.size() == 0) { return true; }
         return changedKeys.hasOnly(allowedAdminSelfUpdateFields) &&
                incomingData.uid == existingData.uid &&
                incomingData.email == existingData.email &&
                incomingData.adminUniqueId == existingData.adminUniqueId && // Admin unique ID should not change
                incomingData.createdAt.toMillis() == existingData.createdAt.toMillis();
      }


      allow update: if studentIsUpdatingOwnAllowedFields(userId) ||
                       adminIsUpdatingStudentLinkStatus(userId) ||
                       adminIsUpdatingOwnProfile(userId);

      allow delete: if isAdmin(); // Only admins can delete user profiles
    }

    // Rules for /admins collection (specific admin operational data, separate from user profile)
    match /admins/{adminId} {
      allow read: if isAdmin() || isOwner(adminId); // Admin can read any, owner can read own
      allow create: if isAdmin() && isOwner(adminId); // Only an admin can create their own admin operational profile
      allow update: if isAdmin() && isOwner(adminId); // Only an admin can update their own
      allow delete: if isAdmin() && isOwner(adminId); // Only an admin can delete their own
    }

    // Rules for /studentLinkRequests collection
    match /studentLinkRequests/{requestId} {

      function requestDataIsValid(requestData) {
        return requestData.studentUserId is string &&
               requestData.studentEmail is string &&
               requestData.studentName is string &&
               requestData.adminUniqueIdTargeted is string &&
               requestData.adminFirebaseId is string &&
               requestData.status is string && (requestData.status == 'pending' || requestData.status == 'accepted' || requestData.status == 'rejected') &&
               requestData.requestedAt is timestamp;
               // studentRollNo is optional
               // resolvedAt and resolvedBy are optional
      }

      // Student creating their own request
      function studentIsCreatingOwnRequest(requestData) {
        let requiredFieldsOnCreate = ['id', 'studentUserId', 'studentEmail', 'studentName', 'adminUniqueIdTargeted', 'adminFirebaseId', 'status', 'requestedAt'];
        // studentRollNo is optional. resolvedAt and resolvedBy are not set on creation.
        let allowedFieldsOnCreate = ['id', 'studentUserId', 'studentEmail', 'studentName', 'studentRollNo', 'adminUniqueIdTargeted', 'adminFirebaseId', 'status', 'requestedAt'];

        return request.auth.uid == requestData.studentUserId &&
               requestData.studentEmail == request.auth.token.email && // Ensure email matches token
               requestData.status == 'pending' &&
               requestData.keys().hasAll(requiredFieldsOnCreate) &&
               requestData.keys().subsetOf(allowedFieldsOnCreate) && // Use subsetOf to allow optional fields
               requestData.requestedAt == request.time &&
               // Ensure fields not for creation are absent
               (!requestData.keys().has('resolvedAt')) &&
               (!requestData.keys().has('resolvedBy'));
      }

      // Admin can read requests targeted at them
      function adminIsTargetOfRequest() {
        return isAdmin() && resource.data.adminFirebaseId == request.auth.uid;
      }

      // Student can read their own request
      function studentIsOwnerOfRequest() {
        return isStudent() && resource.data.studentUserId == request.auth.uid;
      }

      allow read: if adminIsTargetOfRequest() || studentIsOwnerOfRequest();
      allow create: if studentIsCreatingOwnRequest(request.resource.data);

      // Admin updating the status of a request
      function adminIsUpdatingRequestStatus() {
        let allowedUpdateFields = ['status', 'resolvedAt', 'resolvedBy'];
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();

        return isAdmin() &&
               request.resource.data.adminFirebaseId == request.auth.uid && // Admin is the one targeted
               resource.data.status == 'pending' && // Can only update pending requests
               (request.resource.data.status == 'accepted' || request.resource.data.status == 'rejected') && // Valid new statuses
               request.resource.data.resolvedAt == request.time &&
               request.resource.data.resolvedBy == request.auth.uid &&
               changedKeys.hasOnly(allowedUpdateFields) &&
               // Ensure student-related fields are not changed by admin here
               request.resource.data.studentUserId == resource.data.studentUserId &&
               request.resource.data.studentEmail == resource.data.studentEmail &&
               request.resource.data.studentName == resource.data.studentName &&
               request.resource.data.studentRollNo == resource.data.studentRollNo &&
               request.resource.data.adminUniqueIdTargeted == resource.data.adminUniqueIdTargeted &&
               request.resource.data.requestedAt.toMillis() == resource.data.requestedAt.toMillis();
      }

      // Student can update (cancel) their own PENDING request.
      // This effectively means changing status to 'rejected' or a custom 'cancelled_by_student'.
      function studentIsCancellingOwnPendingRequest() {
        let allowedUpdateFields = ['status', 'resolvedAt']; // Student sets status and resolvedAt. resolvedBy could be student's UID.
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();

        return isStudent() &&
               request.auth.uid == resource.data.studentUserId && // Student owns the request
               resource.data.status == 'pending' && // Can only cancel pending requests
               request.resource.data.status == 'rejected' && // Or a custom 'cancelled_by_student' status if you prefer
               request.resource.data.resolvedAt == request.time &&
               // Allow resolvedBy to be student's UID or null if not set
               (request.resource.data.resolvedBy == null || request.resource.data.resolvedBy == request.auth.uid) &&
               changedKeys.hasOnly(allowedUpdateFields) &&
               // Ensure other fields are not changed
               request.resource.data.studentEmail == resource.data.studentEmail &&
               request.resource.data.studentName == resource.data.studentName;
      }

      allow update: if adminIsUpdatingRequestStatus() || studentIsCancellingOwnPendingRequest();

      // Generally, requests are not deleted but marked as resolved/rejected.
      // If deletion is needed, define who can delete (e.g., Admin or owning Student after resolution).
      allow delete: if false; // Example: Disallow deletion for now
    }

    // GridFS Rules (images.files and images.chunks)
    // These are for metadata access control. Actual file access is via download URLs,
    // which can be secured via Firebase Storage security rules if you were using Firebase Storage directly.
    // Since we use /api/images/[fileId] to serve, the auth check is in that API route.
    // These Firestore rules here are mostly for querying metadata if needed.
    match /images.files/{fileId} {
      allow read: if isSignedIn(); // Allow authenticated users to read file metadata
      // Create/Update/Delete of image metadata usually handled by trusted server environment (e.g., API route)
      allow write: if false; // Disallow direct client write/delete to metadata
    }
    match /images.chunks/{chunkId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

  }
}

    